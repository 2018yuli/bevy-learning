fn main() {
    /*
    ////////////////////////////////////////////////////////////////////////////////////
    /// 
    /// Rust 中的借用与引用
    /// 
    ////////////////////////////////////////////////////////////////////////////////////
    */
    let s1 = String::from("I am a superman.");
    let s1 = foo(s1);
    println!("{s1}");

    /*
    ////////////////////////////////////////////////////////////////////////////////////
    /// 
    /// 比如你有一样东西，别人想用一下，可以从你这里借，
    /// 你可以借出。那“引用”概念又是什么呢？其实在 Rust 中，借用和引用是一体两面。
    /// 你把东西借给别人用，也就是别人持有了对你这个东西的引用
    /// 
    ////////////////////////////////////////////////////////////////////////////////////
    /// 实引用也是一种值，并且是固定尺寸的值，一般来说，与机器 CPU 位数一致，比如 64 位或 32 位。
    /// 因为是值，所以就可以赋给另一个变量。
    */
    let a = 10u32;
    let b = &a; // b是变量a的一级引用
    /*
    ////////////////////////////////////////////////////////////////////////////////////
    /// 
    /// 当你创建 let c = &&&&&a; 这样的多重引用时，你确实在创建多层间接的指针。
    /// 每个 & 实际上增加了一个额外的指针层次，这意味着 c 是一个指向指向指向指向 a 的指针。
    /// 在内存中，这会表现为一系列的地址引用，其中每一个引用都指向下一个引用的地址，直到最后一个引用指向 a 的值。
    ///
    ////////////////////////////////////////////////////////////////////////////////////
    */ 
    let c = &&&&&a; // c是变量a的多级引用
    let d = &b; // d是变量a的间接引用
    let e = b; // 引用b再赋值给e，
    // let e = b 做的就是引用的复制操作，并没有再复制一份 a 的值
    println!("{a}");
    println!("{b}");
    println!("The memory address of a is: {:p}", b);
    println!("{c}"); // 是打印时仍然正确获取到了 a 的值，而不会获得内存地址
    println!("{d}");
    println!("{e}");

    /*
    ////////////////////////////////////////////////////////////////////////////////////
    /// 
    /// 这通过借用（borrowing）实现。Rust 的引用有两种类型：
    ///     - 不可变引用 (&T)：允许你读取数据，但不能修改。你可以同时拥有多个不可变引用，只要它们都只用于读取数据。
    ///     - 可变引用 (&mut T)：允许你读取和修改数据。
    ///        在任何给定时刻，只能有一个可变引用指向特定的数据，或者有多个不可变引用，但这两种情况不能同时发生。
    /// 引用的规则主要有：
    ///     - 数据可以有多个不可变引用或一个可变引用，但这两者不能同时存在。
    ///     - 引用必须总是有效的。Rust 在编译时会确保引用不会悬挂，即引用的数据不会在引用之前被释放。
    /// 
    ////////////////////////////////////////////////////////////////////////////////////
    */
    let a = 10u32;
    // cannot mutate immutable variable
    // let b = &mut a;
    // *b = 20;
    // println!("{b}");

    //
    let mut a = 10u32;
    let b = &mut a;
    *b = 20;
    println!("{b}");

    /*
    ////////////////////////////////////////////////////////////////////////////////////
    /// 
    /// 一个所有权型变量的作用域是从它定义时开始到花括号结束。
    ///     - 而引用型变量的作用域不是这样，引用型变量的作用域是从它定义起到它最后一次使用时结束
    /// 一个所有权型变量的可变引用与不可变引用的作用域不能交叠
    /// 
    ////////////////////////////////////////////////////////////////////////////////////
    */
    let mut a = 10u32;
    let b = &mut a;
    *b = 20;
    println!("{b}");
    println!("{a}");

}

// 如果代码中到处都是所有权传来传去，会让代码显得相当冗余
fn foo(s: String) -> String {
    println!("{s}");
    s
}
