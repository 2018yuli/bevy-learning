fn main() {
    /*
    ////////////////////////////////////////////////////////////////////////////////////
    /// 
    /// Rust 中的借用与引用
    /// 
    ////////////////////////////////////////////////////////////////////////////////////
    */
    let s1 = String::from("I am a superman.");
    let s1 = foo(s1);
    println!("{s1}");

    /*
    ////////////////////////////////////////////////////////////////////////////////////
    /// 
    /// 比如你有一样东西，别人想用一下，可以从你这里借，
    /// 你可以借出。那“引用”概念又是什么呢？其实在 Rust 中，借用和引用是一体两面。
    /// 你把东西借给别人用，也就是别人持有了对你这个东西的引用
    /// 
    ////////////////////////////////////////////////////////////////////////////////////
    /// 实引用也是一种值，并且是固定尺寸的值，一般来说，与机器 CPU 位数一致，比如 64 位或 32 位。
    /// 因为是值，所以就可以赋给另一个变量。
    */
    let a = 10u32;
    let b = &a; // b是变量a的一级引用
    /*
    ////////////////////////////////////////////////////////////////////////////////////
    /// 
    /// 当你创建 let c = &&&&&a; 这样的多重引用时，你确实在创建多层间接的指针。
    /// 每个 & 实际上增加了一个额外的指针层次，这意味着 c 是一个指向指向指向指向 a 的指针。
    /// 在内存中，这会表现为一系列的地址引用，其中每一个引用都指向下一个引用的地址，直到最后一个引用指向 a 的值。
    ///
    ////////////////////////////////////////////////////////////////////////////////////
    */ 
    let c = &&&&&a; // c是变量a的多级引用
    let d = &b; // d是变量a的间接引用
    let e = b; // 引用b再赋值给e，
    // let e = b 做的就是引用的复制操作，并没有再复制一份 a 的值
    println!("{a}");
    println!("{b}");
    println!("The memory address of a is: {:p}", b);
    println!("{c}"); // 是打印时仍然正确获取到了 a 的值，而不会获得内存地址
    println!("{d}");
    println!("{e}");

    /*
    ////////////////////////////////////////////////////////////////////////////////////
    /// 
    /// 这通过借用（borrowing）实现。Rust 的引用有两种类型：
    ///     - 不可变引用 (&T)：允许你读取数据，但不能修改。你可以同时拥有多个不可变引用，只要它们都只用于读取数据。
    ///     - 可变引用 (&mut T)：允许你读取和修改数据。
    ///        在任何给定时刻，只能有一个可变引用指向特定的数据，或者有多个不可变引用，但这两种情况不能同时发生。
    /// 引用的规则主要有：
    ///     - 数据可以有多个不可变引用或一个可变引用，但这两者不能同时存在。
    ///     - 引用必须总是有效的。Rust 在编译时会确保引用不会悬挂，即引用的数据不会在引用之前被释放。
    /// 
    ////////////////////////////////////////////////////////////////////////////////////
    */
    let a = 10u32;
    // cannot mutate immutable variable
    // let b = &mut a;
    // *b = 20;
    // println!("{b}");

    //
    let mut a = 10u32;
    let b = &mut a;
    *b = 20;
    println!("{b}");

    /*
    ////////////////////////////////////////////////////////////////////////////////////
    /// 
    /// 一个所有权型变量的作用域是从它定义时开始到花括号结束。
    ///     - 而引用型变量的作用域不是这样，引用型变量的作用域是从它定义起到它最后一次使用时结束
    /// 一个所有权型变量的可变引用与不可变引用的作用域不能交叠
    /// 
    ////////////////////////////////////////////////////////////////////////////////////
    */
    let mut a = 10u32;
    let b = &mut a;
    *b = 20;
    println!("{b}");
    println!("{a}");

    /*
    ////////////////////////////////////////////////////////////////////////////////////
    /// 
    /// 在有（可变and不可变）借用的情况下，不能对所有权变量进行更改值的操作（写操作）
    /// 
    ////////////////////////////////////////////////////////////////////////////////////
    */
    let mut a = 10u32;
    let r1 = &a;
    // cannot assign to `a` because it is borrowed
    // a = 20;
    println!("{r1}");

    /*
    ////////////////////////////////////////////////////////////////////////////////////
    /// 
    /// 一些规则
    ///     - 所有权型变量的作用域是从它定义时开始到所属那层花括号结束
    ///     - 引用型变量的作用域是从它定义起到它最后一次使用时结束
    ///     - 引用（不可变引用和可变引用）型变量的作用域不会长于所有权变量的作用域
    ///     - 一个所有权型变量的不可变引用可以同时存在多个，可以复制多份
    ///     - 一个所有权型变量的可变引用与不可变引用的作用域不能交叠，也可以说不能同时存在
    ///     - 某个时刻对某个所有权型变量只能存在一个可变引用，不能有超过一个可变借用同时存在
    ///     - 在有借用存在的情况下，不能通过原所有权型变量对值进行更新
    /// 
    ////////////////////////////////////////////////////////////////////////////////////
    */

    /*
    ////////////////////////////////////////////////////////////////////////////////////
    /// 
    /// 一些规则
    ///     一个所有权型变量的可变引用也具有所有权特征，它可以被理解为那个所有权变量的独家代理，具有排它性
    /// 
    ////////////////////////////////////////////////////////////////////////////////////
    */
    let mut a = 10u32;
    let r1 = &mut a;
    let r2 = r1;
    // borrow of moved value: `r1`
    // println!("{r1}")

    /*
    ////////////////////////////////////////////////////////////////////////////////////
    /// 
    /// 多级引用
    ///     对于多级可变引用，要利用可变引用去修改目标资源的值的时候，需要做正确的多级解引用操作
    ///     这里对二级可变引用 c，必须使用对应的二级解引用操作
    ///     只有全是 “多级可变” 引用的情况下，才能修改到目标资源的值
    /// 
    ////////////////////////////////////////////////////////////////////////////////////
    */
    let mut a1 = 10u32;
    let mut b = &mut a1;
    *b = 20;
    let c = &mut b;
    **c = 30; // 多级解引用操作
    println!("{c}");

    let s1 = String::from("I am a superman.");
    foo1(&s1); // 注意这里传的是字符串的引用 &s1
    println!("{s1}"); // 这里可以打印s1的值了

    let mut s1 = String::from("I am a superman.");
    println!("{s1}");
    foo2(&mut s1); // 注意这里传的是字符串的可变引用 &mut s1
    println!("{s1}");

}

// 如果代码中到处都是所有权传来传去，会让代码显得相当冗余
fn foo(s: String) -> String {
    println!("{s}");
    s
}

// 使用引用改进函数的定义
fn foo1(s: &String) {
    println!("in fn foo: {s}");
}

fn foo2(s: &mut String) {
    s.push_str(" You are badman.");
}